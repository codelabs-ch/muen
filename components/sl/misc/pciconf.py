#!/usr/bin/env python3
"""
PCI device configuration generator.

Creates PCI device configurations for all devices
assigned to a given subject. Assignment is either in the subject's
<devices> element or a <component> <map> element pointing to a device.
"""
import argparse
from pathlib import Path

import _paths
import muutils

from lxml import etree


def main():
    parser = argparse.ArgumentParser(description="PCI device configuration generator")
    parser.add_argument("--src_policy", type=Path, help=("Muen XML system policy"))
    parser.add_argument(
        "--out", type=str, help=("Filename of source file to be generated")
    )
    parser.add_argument("--subject", type=str, help=("Name of subject"))
    parser.add_argument(
        "--package",
        type=str,
        default="Pciconf",
        help=("Name of Ada package"),
    )
    args = parser.parse_args()
    run(
        policy_path=args.src_policy,
        subject=args.subject,
        outfile=args.out,
        pkg=args.package,
    )


def get_physical_device(policy: etree._Element, name: str) -> etree._Element | None:
    return policy.xpath(f"/system/hardware/devices/device[@name='{name}' and pci/bars]")


def validate_devices(
    policy: etree._Element, devices: list[etree._Element]
) -> dict[str, etree._Element] | None:
    res: dict[str, etree._Element] = {}
    for d in devices:
        physical: str | None = d.get("physical")
        assert isinstance(physical, str)
        logical: str | None = d.get("logical")
        assert isinstance(logical, str)
        print(f"Validating {logical} -> {physical}")
        dev = get_physical_device(policy=policy, name=physical)
        if dev:
            print(f"Direct hit for {physical}")
            res[logical] = dev[0]
            continue

        # might be an alias
        alias = policy.xpath(
            f"/system/platform/mappings/aliases/alias[@name='{physical}']"
        )
        if alias:
            aname: str = alias[0].get("physical")
            print(f"Alias found for {physical}: {aname}")
            dev = get_physical_device(policy=policy, name=aname)
            if dev:
                print(f"Device found for alias {aname}")
                res[logical] = dev[0]
                continue

        # might be a device class
        the_class = policy.xpath(
            f"/system/platform/mappings/classes/class[@name='{physical}']"
        )
        if the_class:
            print(f"Class found for {physical}")
            counter: int = 1
            class_devices = the_class[0].xpath("device")
            for cd in class_devices:
                name: str = cd.get("physical")
                dev = get_physical_device(policy=policy, name=name)
                if dev:
                    print(f"Found class device {name}")
                    res[f"{logical}{counter}"] = dev[0]
                    counter += 1

    return res


def spaces(i: int):
    return " " * i * 3


def get_bar_config(dev: etree._Element) -> str:
    res: str = ""
    bars = dev.xpath("pci/bars/*")
    has_others: bool = len(bars) != 5

    for bar in bars:
        ref: str = bar.get("ref")
        index: str = bar.tag[-1]
        if bar.tag.startswith("memBar"):
            mem = dev.xpath(f"memory[@name='{ref}']")[0]
            addr: int = muutils.ada_hex_to_int(mem.get("physicalAddress"))
            size: str = mem.get("size")
            bit64: bool = bar.get("bit64") == "true"
            prefetchable: bool = bar.get("prefetchable") == "true"
            if bit64:
                addr |= 4
            if prefetchable:
                addr |= 8
            addr = muutils.int_to_ada_hex(addr)
        else:
            port = dev.xpath(f"ioPort[@name='{ref}']")[0]
            start: int = muutils.ada_hex_to_int(port.get("start"))
            end: int = muutils.ada_hex_to_int(port.get("end"))
            addr = muutils.int_to_ada_hex(start | 1)
            size = muutils.int_to_ada_hex(end - start)

        res += f"{spaces(5)}{index} => (Register_Value => {addr},\n"
        res += f"{spaces(5)}      Size           => {size}),\n"

    if has_others:
        res += f"{spaces(5)}others => Mupci.Null_BAR\n"

    return res


def write_spec(devices: dict[str, etree._Element], outfile: str, pkg: str):
    count: int = 1
    with open(outfile, "w") as f:
        f.write("with Mupci;\n\n")
        f.write("--D @Interface\n")
        f.write("--D This package contains the PCI device configuration\n")
        f.write("--D of devices assigned to the subject.\n")
        f.write("--D The package is auto-generated by the pciconf.py script.\n")
        f.write(f"package {pkg} is\n\n")
        f.write(
            f"   subtype Device_Array is Mupci.Device_Array (Positive range 1 .. {len(devices)});\n\n"
        )

        f.write("   Devices : constant Device_Array := (\n")
        for name, e in devices.items():
            f.write(
                f"      {count} => (SID         => 8,\n"  # TODO
                f"            Device_ID   => {e.xpath('pci/identification/@deviceId')[0]},\n"
                f"            Vendor_ID   => {e.xpath('pci/identification/@vendorId')[0]},\n"
                f"            Revision_ID => {e.xpath('pci/identification/@revisionId')[0]},\n"
                f"            Class_Code  => {e.xpath('pci/identification/@classcode')[0]},\n"
                "            Reset       => Mupci.Reset_Method_FLR,\n"
                "            BARs        => (\n"
            )
            f.write(get_bar_config(dev=e))
            if len(devices) == count:
                f.write("            ))\n")
            else:
                f.write("            ),\n")
            count += 1
        f.write("   );\n")
        f.write(f"end {pkg};\n")


def run(policy_path: Path, subject: str, outfile: str, pkg: str):
    print("Reading policy from '" + str(policy_path) + "'")
    xml_parser = etree.XMLParser(remove_blank_text=True)
    policy: etree._Element = etree.parse(policy_path, xml_parser).getroot()

    subj = policy.xpath(f"/system/subjects/subject[@name='{subject}']")
    if not subj:
        print(f"No such subject '{subject}', exiting")
        return

    devices = subj[0].xpath("devices/device")
    devices += subj[0].xpath("component/map")
    devices = validate_devices(policy=policy, devices=devices)
    if not devices:
        print("No viable device found, exiting")
        return

    write_spec(devices=devices, outfile=outfile, pkg=pkg)


if __name__ == "__main__":
    main()
